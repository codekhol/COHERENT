This is Info file screen.info, produced by Makeinfo-1.55 from the input
file screen.texinfo.

   This file documents the the `Screen' virtual terminal manager.

   Copyright (c) 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: screen.info,  Node: Top,  Next: Overview,  Prev: (dir),  Up: (dir)

Screen
******

   This file documents the `Screen' virtual terminal manager, version
3.5.

* Menu:

* Overview::                    Preliminary information.
* Getting Started::             An introduction to `screen'.
* Invoking Screen::             Command line options for `screen'.
* Customization::               The `.screenrc' file.
* Commands::                    List all of the commands.
* New Window::                  Running a program in a new window.
* Selecting::                   Selecting a window to display.
* Session Management::          Suspending or detaching a session.
* Window Settings::             titles, logging, etc.
* Virtual Terminal::            Controlling the `screen' VT100 emulation.
* Copy and Paste::              Exchanging text between windows and sessions.
* Subprocess Execution::	I/O filtering with `exec'.
* Key Binding::                 Binding commands to keys.
* Flow Control::                Trap or pass flow control characters.
* Termcap::                     Tweaking your terminal's termcap entry.
* Message Line::                The `screen' message line.
* Logging::                     Keeping a record of your session.
* Startup::                     Functions only useful at `screen' startup.
* Miscellaneous::               Various other commands.
* Environment::                 Environment variables used by `screen'.
* Files::                       Files used by `screen'.
* Credits::                     Who's who of `screen'.
* Bugs::                        What to do if you find a bug.
* Installation::                Getting `screen' running on your system.
* Concept Index::               Index of concepts.
* Command Index::               Index of all `screen' commands.
* Keystroke Index::             Index of default key bindings.


File: screen.info,  Node: Overview,  Next: Getting Started,  Prev: Top,  Up: Top

Overview
********

   Screen is a full-screen window manager that multiplexes a physical
terminal between several processes, typically interactive shells.  Each
virtual terminal provides the functions of the DEC VT100 terminal and,
in addition, several control functions from the ANSI X3.64 (ISO 6429)
and ISO 2022 standards (e.g. insert/delete line and support for multiple
character sets).  There is a scrollback history buffer for each virtual
terminal and a copy-and-paste mechanism that allows the user to move
text regions between windows.

   When `screen' is called, it creates a single window with a shell in
it (or the specified command) and then gets out of your way so that you
can use the program as you normally would.  Then, at any time, you can
create new (full-screen) windows with other programs in them (including
more shells), kill the current window, view a list of the active
windows, turn output logging on and off, copy text between windows, view
the scrollback history, switch between windows, etc.  When a program
terminates, `screen' (per default) kills the window that contained it.
If this window was in the foreground, the display switches to the
previously displayed window; if none are left, `screen' exits.

   Everything you type is sent to the program running in the current
window.  The only exception to this is the one keystroke that is used to
initiate a command to the window manager.  By default, each command
begins with a control-a (abbreviated `C-a' from now on), and is
followed by one other keystroke.  The command character (*note Command
Character::.) and all the key bindings (*note Key Binding::.) can be
fully customized to be anything you like, though they are always two
characters in length.

   The standard way to create a new window is to type `C-a c'.  This
creates a new window running a shell and switches to that window
immediately, regardless of the state of the process running in the
current window.  Similarly, you can create a new window with a custom
command in it by first binding the command to a keystroke (in your
`.screenrc' file or at the `C-a :' command line) and then using it just
like the `C-a c' command.  In addition, new windows can be created by
running a command like:

     screen emacs prog.c

from a shell prompt within a previously created window.  This will not
run another copy of `screen', but will instead supply the command name
and its arguments to the window manager (specified in the $STY
environment variable) who will use it to create the new window.  The
above example would start the `emacs' editor (editing `prog.c') and
switch to its window.

   If `/etc/utmp' is writable by `screen', an appropriate record will
be written to this file for each window, and removed when the window is
closed.  This is useful for working with `talk', `script', `shutdown',
`rsend', `sccs' and other similar programs that use the utmp file to
determine who you are. As long as `screen' is active on your terminal,
the terminal's own record is removed from the utmp file.  *Note Login::.


File: screen.info,  Node: Getting Started,  Next: Invoking Screen,  Prev: Overview,  Up: Top

Getting Started
***************

   Before you begin to use `screen' you'll need to make sure you have
correctly selected your terminal type, just as you would for any other
termcap/terminfo program.  (You can do this by using `tset', `qterm',
or just `set term=mytermtype', for example.)

   If you're impatient and want to get started without doing a lot more
reading, you should remember this one command: `C-a ?' (*note Key
Binding::.).  Typing these two characters will display a list of the
available `screen' commands and their bindings. Each keystroke is
discussed in the section on keystrokes (*note Default Key Bindings::.).
Another section (*note Customization::.) deals with the contents of your
`.screenrc'.

   If possible, choose a version of your terminal's termcap that has
automatic margins turned *off*.  This will ensure an accurate and
optimal update of the screen in all circumstances.  The next best thing
is an auto-margin terminal that allows the last position on the screen
to be updated without scrolling the screen (such as a vt100).  This also
allows the entire screen to be updated.  If all you've got is a "true"
auto-margin terminal, `screen' will be content to use it, but updating
a character put into the last position on the screen may not be
possible until the screen scrolls or the character is moved into a safe
position in some other way.  This delay can be shortened by using a
terminal with insert-character capability.

   If your terminal is of the second type (firm-margined `am'), you will
want to let `screen' know about this, since a normal termcap doesn't
distinguish this type of automatic margins from a "true" `am' terminal.
You do this by specifying the `xn' capability in your termcap (*note
`termcap' command: Termcap.), or by using the `-L' command-line option.
`screen' needs this information to correctly update the screen.  You
don't need to worry about this if your terminal type starts with `vt',
as `screen' assumes `xn' in that case.

   If you are using a "true" auto-margin terminal (no `xn') at low baud
rates, you may want to turn on a more optimal output mode by including
the flag `OP' in your termcap entry, or by specifying the `-O'
command-line option.  The trade-off is that `screen' will no-longer
accurately emulate the vt100's line-end quirks (e.g. the screen will
scroll after putting *one* character in the last screen position).

   *Note Special Capabilities::, for more information about telling
`screen' what kind of terminal you have.


File: screen.info,  Node: Invoking Screen,  Next: Customization,  Prev: Getting Started,  Up: Top

Invoking `Screen'
*****************

   Screen has the following command-line options:

`-a'
     Include *all* capabilities (with some minor exceptions) in each
     window's termcap, even if `screen' must redraw parts of the display
     in order to implement a function.

`-A'
     Adapt the sizes of all windows to the size of the display.  By
     default, `screen' may try to restore its old window sizes when
     attaching to resizeable terminals (those with `WS' in their
     descriptions, e.g.  `suncmd' or some varieties of `xterm').

`-c FILE'
     Use FILE as the user's configuration file instead of the default
     of `$HOME/.screenrc'.

`-d [PID.SESSIONNAME]'
`-D [PID.SESSIONNAME]'
     Do not start `screen', but instead detach a `screen' session
     running elsewhere (*note Detach::.).  `-d' has the same effect as
     typing `C-a d' from the controlling terminal for the session.
     `-D' is the equivalent to the power detach key.  If no session can
     be detached, this option is ignored.  The combination `screen -D
     -r' can be used to log out from a remote terminal and transport the
     session running there to your current terminal.  *Note*: It is a
     good idea to check the status of your sessions with `screen -list'
     before using this option.

`-e XY'
     Set the command character to X, and the character generating a
     literal command character (when typed after the command character)
     to Y.  The defaults are `C-a' and `a', which can be specified as
     `-e^Aa'.  This option is equivalent to the `escape' command (*note
     Command Character::.).

`-f'
`-fn'
`-fa'
     Set flow-control to on, off, or automatic switching mode,
     respectively.  This option is equivalent to the `defflow' command
     (*note Flow Control::.).

`-h NUM'
     Set the history scrollback buffer to be NUM lines high.
     Equivalent to the `defscrollback' command (*note Copy::.).

`-i'
     Cause the interrupt key (usually `C-c') to interrupt the display
     immediately when flow control is on.  This option is equivalent to
     the `interrupt' argument to the `defflow' command (*note Flow
     Control::.). Its use is discouraged.

`-l'
`-ln'
     Turn login mode on or off (for `/etc/utmp' updating).  This option
     is equivalent to the `deflogin' command (*note Login::.).

`-ls'
`-list'
     Do not start `screen', but instead print a list of session
     identification strings (usually of the form PID.TTY.HOST; *note
     Session Name::.).  Sessions marked `detached' can be resumed with
     `screen -r'.  Those marked `attached' are running and have a
     controlling terminal.  Sessions marked as `dead' should be
     thoroughly checked and removed.  Ask your system administrator if
     you are not sure why they died. Remove sessions with the `-wipe'
     option.

`-L'
     Tell `screen' that your auto-margin terminal allows programs to
     write to the last column of the last row of the screen without
     scrolling.  This can also be set in your `.screenrc' by specifying
     `xn' in a `termcap' command (*note Termcap::.).

`-m'
     Tell `screen' to ignore the `$STY' environment variable.  When
     this option is used, a new session will always be created,
     regardless of whether `screen' is being called from within another
     `screen' session or not.

`-O'
     Select an output mode for your terminal which is more optimal than
     true vt100 emulation (only affects auto-margin terminals without
     `xn').  This can also be set in your `.screenrc' by specifying
     `OP' in a `termcap' command (*note Termcap::.).

`-r [PID.SESSIONNAME]'
     Resume a detached `screen' session.  No other options (except `-d'
     or `-D') may be specified, though the session name (*note Session
     Name::.) may be needed to distinguish between multiple detached
     `screen' sessions.

`-R'
     Resume the first appropriate detached `screen' session.  If
     successful, all other command-line options are ignored.  If no
     detached session exists, start a new session using the specified
     options, just as if `-R' had not been specified.  This option is
     set by default if screen is run as a login-shell.

`-s PROGRAM'
     Set the default shell to be PROGRAM.  By default, `screen' uses
     the value of the environment variable `$SHELL', or `/bin/sh' if it
     is not defined.  This option is equivalent to the `shell' command
     (*note Shell::.).

`-S SESSIONNAME'
     Set the name of the new session to SESSIONNAME.  This option can
     be used to specify a meaningful name for the session in place of
     the default TTY.HOST suffix.  This name identifies the session for
     the `screen -list' and `screen -r' commands.  This option is
     equivalent to the `sessionname' command (*note Session Name::.).

`-t NAME'
     Set the title (name) for the default shell or specified program.
     This option is equivalent to the `shelltitle' command (*note
     Shell::.).

`-v'
     Print the version number.

`-wipe'
     List available screens like `screen -ls', but remove destroyed
     sessions instead of marking them as `dead'.

`-x'
     Attach to a session which is already attached elsewhere
     (multi-display mode).


File: screen.info,  Node: Customization,  Next: Commands,  Prev: Invoking Screen,  Up: Top

Customizing `Screen'
********************

   You can modify the default settings for `screen' to fit your tastes
either through a personal `.screenrc' file which contains commands to
be executed at startup, or on the fly using the `colon' command.

* Menu:

* Startup Files::               The `.screenrc' file.
* Colon::                       Entering customization commands interactively.


File: screen.info,  Node: Startup Files,  Next: Colon,  Up: Customization

The `.screenrc' file
====================

   When `screen' is invoked, it executes initialization commands from
the files `.screenrc' in the user's home directory and
`/usr/local/etc/screenrc'.  These defaults can be overridden in the
following ways: For the global screenrc file `screen' searches for the
environment variable `$SYSSCREENRC' (this override feature may be
disabled at compile-time).  The user specific screenrc file is searched
for in `$ISCREENRC', then `$SCREENRC', then ``$HOME'/.iscreenrc' and
finally defaults to ``$HOME'/.screenrc'.  The command line option `-c'
specifies which file to use (*note Invoking Screen::..  Commands in
these files are used to set options, bind commands to keys, and to
automatically establish one or more windows at the beginning of your
`screen' session.  Commands are listed one per line, with empty lines
being ignored.  A command's arguments are separated by tabs or spaces,
and may be surrounded by single or double quotes.  A `#' turns the rest
of the line into a comment, except in quotes.  Unintelligible lines are
warned about and ignored.  Commands may contain references to
environment variables.  The syntax is the shell-like `$VAR' or
`${VAR}'.  Note that this causes incompatibility with previous `screen'
versions, as now the '$'-character has to be protected with '\' if no
variable substitution is intended. A string in single-quotes is also
protected from variable substitution.


File: screen.info,  Node: Colon,  Prev: Startup Files,  Up: Customization

Colon
=====

   Customization can also be done online, with this command:

 - Command: colon
     (`C-a :')
     Allows you to enter `.screenrc' command lines.  Useful for
     on-the-fly modification of key bindings, specific window creation
     and changing settings.  Note that the `set' keyword no longer
     exists, as of version 3.3.  Change default settings with commands
     starting with `def'.  You might think of this as the `ex' command
     mode of `screen', with `copy' as its `vi' command mode (*note Copy
     and Paste::.).


File: screen.info,  Node: Commands,  Next: New Window,  Prev: Customization,  Up: Top

Commands
********

   A command in `screen' can either be bound to a key, invoked from a
screenrc file, or called from the `colon' prompt (*note
Customization::.).  As of version 3.3, all commands can be bound to
keys, although some may be less useful than others.

   In this manual, a command definition looks like this:

- Command: command [-n] ARG1 [ARG2] ...
     (KEYBINDINGS)
     This command does something, but I can't remember what.

   An argument in square brackets (`[]') is optional.  Many commands
take an argument of `on' or `off', which is indicated as STATE in the
definition.

* Menu:

* Default Key Bindings::	`screen' keyboard commands.
* Command Summary::             List of all commands.


File: screen.info,  Node: Default Key Bindings,  Next: Command Summary,  Up: Commands

Default Key Bindings
====================

   As mentioned previously, each keyboard command consists of a `C-a'
followed by one other character.  For your convenience, all commands
that are bound to lower-case letters are also bound to their control
character counterparts (with the exception of `C-a a'; see below).
Thus, both `C-a c' and `C-a C-c' can be used to create a window.

   The following table shows the default key bindings:

`C-a ''
`C-a "'
     (select)
     Prompt for a window identifier and switch.  *Note Selecting::.

`C-a 0...9'
     (select 0...select 9)
     Switch to window number 0...9.  *Note Selecting::.

`C-a C-a'
     (other)
     Toggle to the window displayed previously.  *Note Selecting::.

`C-a a'
     (meta)
     Send the command character (C-a) to window. See `escape' command.
     *Note Command Character::.

`C-a A'
     (title)
     Allow the user to enter a title for the current window.  *Note
     Naming Windows::.

`C-a c'
`C-a C-c'
     (screen)
     Create a new window with a shell and switch to that window.  *Note
     Screen Command::.

`C-a C'
     (clear)
     Clear the screen.  *Note Clear::.

`C-a d'
`C-a C-d'
     (detach)
     Detach `screen' from this terminal.  *Note Detach::.

`C-a D D'
     (pow_detach)
     Detach and logout.  *Note Power Detach::.

`C-a f'
`C-a C-f'
     (flow)
     Cycle flow among `on', `off' or `auto'.  *Note Flow::.

`C-a C-g'
     (vbell)
     Toggle visual bell mode.  *Note Bell::.

`C-a h'
     (hardcopy)
     Write a hardcopy of the current window to the file "hardcopy.N".
     *Note Hardcopy::.

`C-a H'
     (log)
     Toggle logging of the current window to the file "screenlog.N".
     *Note Log::.

`C-a i'
`C-a C-i'
     (info)
     Show info about the current window.  *Note Info::.

`C-a k'
`C-a C-k'
     (kill)
     Destroy the current window.  *Note Kill::.

`C-a l'
`C-a C-l'
     (redisplay)
     Fully refresh the current window.  *Note Redisplay::.

`C-a L'
     (login)
     Toggle the current window's login state.  *Note Login::.

`C-a m'
`C-a C-m'
     (lastmsg)
     Repeat the last message displayed in the message line.  *Note Last
     Message::.

`C-a M'
     (monitor) Toggle monitoring of the current window.  *Note
     Monitor::.

`C-a SPC'
`C-a n'
`C-a C-n'
     (next)
     Switch to the next window.  *Note Selecting::.

`C-a N'
     (number)
     Show the number (and title) of the current window.  *Note Number::.

`C-a p'
`C-a C-p'
`C-a C-h'
`C-a BackSpace'
     (prev)
     Switch to the previous window (opposite of `C-a n').  *Note
     Selecting::.

`C-a q'
`C-a C-q'
     (xon)
     Send a ^Q (ASCII XON) to the current window.  *Note XON/XOFF::.

`C-a r'
`C-a C-r'
     (wrap)
     Toggle the current window's line-wrap setting (turn the current
     window's automatic margins on or off).  *Note Wrap::.

`C-a s'
`C-a C-s'
     (xoff)
     Send a ^S (ASCII XOFF) to the current window.  *Note XON/XOFF::.

`C-a t'
`C-a C-t'
     (time)
     Show the load average and xref.  *Note Time::.

`C-a v'
`C-a C-v'
     (version)
     Display the version and compilation date.  *Note Version::.

`C-a w'
`C-a C-w'
     (windows)
     Show a list of active windows.  *Note Windows::.

`C-a W'
     (width)
     Toggle between 80 and 132 columns.  *Note Width::.

`C-a x'
`C-a C-x'
     (lockscreen)
     Lock your terminal.  *Note Lock::.

`C-a z'
`C-a C-z'
     (suspend)
     Suspend `screen'.  *Note Suspend::.

`C-a Z'
     (reset)
     Reset the virtual terminal to its "power-on" values.  *Note
     Reset::.

`C-a .'
     (dumptermcap)
     Write out a `.termcap' file.  *Note Dump Termcap::.

`C-a ?'
     (help)
     Show key bindings.  *Note Help::.

`C-a C-\'
     (quit)
     Kill all windows and terminate `screen'.  *Note Quit::.

`C-a :'
     (colon)
     Enter a command line.  *Note Colon::.

`C-a ['
`C-a C-['
`C-a ESC'
     (copy)
     Enter copy/scrollback mode.  *Note Copy::.

`C-a ]'
`C-a C-]'
     (paste)
     Write the contents of the paste buffer to the stdin queue of the
     current window.  *Note Paste::.

`C-a {'
     (history)
     Copy and paste a previous (command) line.  *Note History::.

`C-a >'
     (writebuf)
     Write the pastebuffer out to the screen-exchange file.  *Note
     Screen-Exchange::.

`C-a <'
     (readbuf)
     Read the screen-exchange file into the pastebuffer.  *Note
     Screen-Exchange::.

`C-a ='
     (removebuf)
     Delete the screen-exchange file.  *Note Screen-Exchange::.

`C-a _'
     (silence)
     Start/stop monitoring the current window for inactivity. *Note
     Silence::,


File: screen.info,  Node: Command Summary,  Prev: Default Key Bindings,  Up: Commands

Command Summary
===============

`acladd USERNAME'
     Allow other user in this session.  *Note Multiuser::.

`aclchg USERNAME PERMBITS LIST'
     Change a user's permissions.  *Note Multiuser::.

`acldel USERNAME'
     Disallow other user in this session.  *Note Multiuser::.

`activity MESSAGE'
     Set the activity notification message.  *Note Monitor::.

`allpartial STATE'
     Set all windows to partial refresh.  *Note Redisplay::.

`at [IDENT][`#'|`*'|`%'] COMMAND [ARGS]'
     Execute a command at other displays or windows.  *Note At::.

`autodetach STATE'
     Automatically detach the session on SIGHUP.  *Note Detach::.

`autonuke STATE'
     Enable a clear screen to discard unwritten output.  *Note
     Autonuke::.

`bell MESSAGE'
     Set the bell notification message.  *Note Bell::.

`bind KEY [COMMAND [ARGS]]'
     Bind a command to a key.  *Note Bind::.

`break [DURATION]'
     Send a break signal to the current window.  *Note Break::.

`bufferfile [EXCHANGE-FILE]'
     Select a file for screen-exchange.  *Note Screen-Exchange::.

`chdir [DIRECTORY]'
     Change the current directory for future windows.  *Note Chdir::.

`clear'
     Clear the window screen.  *Note Clear::.

`colon'
     Enter a `screen' command.  *Note Colon::.

`console [STATE]'
     Grab or ungrab console output.  *Note Console::.

`copy'
     Enter copy mode.  *Note Copy::.

`copy_reg [KEY]'
     Store the copy buffer to a register.  *Note Registers::.

`crlf STATE'
     Select line break behavior for copying.  *Note Line Termination::.

`debug STATE'
     Suppress/allow debugging output.  *Note Debug::.

`defautonuke STATE'
     Select default autonuke behavior.  *Note Autonuke::.

`defflow FSTATE'
     Select default flow control behavior.  *Note Flow::.

`deflogin STATE'
     Select default utmp logging behavior.  *Note Login::.

`defmode MODE'
     Select default file mode for ptys.  *Note Mode::.

`defmonitor STATE'
     Select default activity monitoring behavior.  *Note Monitor::.

`defobuflimit LIMIT'
     Select default output buffer limit.  *Note Obuflimit::.

`defscrollback NUM'
     Set default lines of scrollback.  *Note Scrollback::.

`defwrap STATE'
     Set default line-wrapping behavior.  *Note Wrap::.

`detach'
     Disconnect `screen' from the terminal.  *Note Detach::.

`dumptermcap'
     Write the window's termcap entry to a file.  *Note Dump Termcap::.

`echo [-n] MESSAGE'
     Display a message on startup.  *Note Startup::.

`escape XY'
     Set the command and `meta' characters.  *Note Command Character::.

`exec [[FDPAT] COMMAND [ARGS ...]]'
     Run a subprocess (filter).  *Note Exec::.

`flow [FSTATE]'
     Set flow control behavior.  *Note Flow::.

`hardcopy'
     Write out the contents of the current window.  *Note Hardcopy::.

`hardcopy_append STATE'
     Append to hardcopy files.  *Note Hardcopy::.

`hardcopydir DIRECTORY'
     Place, where to dump hardcopy files.  *Note Hardcopy::.

`hardstatus [STATE]'
     Use the hardware status line.  *Note Hardware Status Line::.

`height [LINES]'
     Set display height.  *Note Height::.

`help'
     Display current key bindings.  *Note Help::.

`history'
     Find previous command beginning ....  *Note History::.

`info'
     Display terminal settings.  *Note Info::.

`ins_reg [KEY]'
     Paste the contents of a register.  *Note Registers::.

`kill'
     Destroy the current window.  *Note Kill::.

`lastmsg'
     Redisplay the last message.  *Note Last Message::.

`license'
     Display licensing information.  *Note Startup::.

`lockscreen'
     Lock the controlling terminal.  *Note Lock::.

`log [STATE]'
     Log all output in the current window.  *Note Log::.

`logdir DIRECTORY'
     Place where to collect logfiles.  *Note Log::.

`login [STATE]'
     Log the window in `/etc/utmp'.  *Note Login::.

`markkeys STRING'
     Rebind keys in copy mode.  *Note Copy Mode Keys::.

`meta'
     Insert the command character.  *Note Command Character::.

`monitor [STATE]'
     Monitor activity in window.  *Note Monitor::.

`msgminwait SEC'
     Set minimum message wait.  *Note Message Wait::.

`msgwait SEC'
     Set default message wait.  *Note Message Wait::.

`multiuser STATE'
     Go into single or multi user mode. *Note Multiuser::.

`nethack STATE'
     Use `nethack'-like error messages.  *Note Nethack::.

`next'
     Switch to the next window.  *Note Selecting::.

`number [N]'
     Change/display the current window's number.  *Note Number::.

`obuflimit [LIMIT]'
     Select output buffer limit.  *Note Obuflimit::.

`other'
     Switch to the window you were in last.  *Note Selecting::.

`partial STATE'
     Set window to partial refresh.  *Note Redisplay::.

`password [CRYPTED_PW]'
     Set reattach password.  *Note Detach::.

`paste'
     Paste contents of copy buffer.  *Note Paste::.

`pow_break'
     Close and Reopen the window's terminal.  *Note Break::.

`pow_detach'
     Detach and hang up.  *Note Power Detach::.

`pow_detach_msg MESSAGE'
     Set message displayed on `pow_detach'.  *Note Power Detach::.

`prev'
     Switch to the previous window.  *Note Selecting::.

`process [KEY]'
     Treat a register as input to `screen'.  *Note Registers::.

`quit'
     Kill all windows and exit.  *Note Quit::.

`readbuf'
     Read the copy buffer from the screen-exchange file.  *Note
     Screen-Exchange::.

`redisplay'
     Redisplay the current window.  *Note Redisplay::.

`register KEY STRING'
     Store a string to a register.  *Note Registers::.

`removebuf'
     Delete the screen-exchange file.  *Note Screen-Exchange::.

`reset'
     Reset the terminal settings for the window.  *Note Reset::.

`screen [OPTS] [N] [CMD [ARGS]]'
     Create a new window.  *Note Screen Command::.

`scrollback NUM'
     Set size of scrollback buffer.  *Note Scrollback::.

`select [N]'
     Switch to a specified window.  *Note Selecting::.

`sessionname [NAME]'
     Name this session.  *Note Session Name::.

`setenv [VAR [STRING]]'
     Set an environment variable for new windows.  *Note Setenv::.

`shell COMMAND'
     Set the default program for new windows.  *Note Shell::.

`shelltitle TITLE'
     Set the default name for new windows.  *Note Shell::.

`silence [STATE|SECONDS]'
     Monitor window for inactivity.  *Note Silence::.

`silencewait SECONDS'
     Default timeout to trigger an inactivity notify.  *Note Silence::.

`sleep NUM'
     Pause during startup.  *Note Startup::.

`slowpaste MSEC'
     Slow down pasting.  *Note Paste::.

`startup_message STATE'
     Display copyright notice on startup.  *Note Startup::.

`suspend'
     Put session in background.  *Note Suspend::.

`term TERM'
     Set `$TERM' for new windows.  *Note Term::.

`termcap TERM TERMINAL-TWEAKS [WINDOW-TWEAKS]'
     Tweak termcap entries for best performance.  *Note Termcap
     Syntax::.

`terminfo TERM TERMINAL-TWEAKS [WINDOW-TWEAKS]'
     Ditto, for terminfo systems.  *Note Termcap Syntax::.

`time'
     Display time and load average.  *Note Time::.

`title [WINDOWTITLE]'
     Set the name of the current window.  *Note Title Command::.

`unsetenv VAR'
     Unset environment variable for new windows.  *Note Setenv::.

`vbell [STATE]'
     Use visual bell.  *Note Bell::.

`vbell_msg MESSAGE'
     Set vbell message.  *Note Bell::.

`vbellwait SEC'
     Set delay for vbell message.  *Note Bell::.

`version'
     Display `screen' version.  *Note Version::.

`wall MESSAGE ...'
     Write a message to all displays.  *Note Multiuser::.

`width [NUM]'
     Set the width of the window.  *Note Width::.

`windows'
     List active windows.  *Note Windows::.

`wrap [STATE]'
     Control line-wrap behavior.  *Note Wrap::.

`writebuf'
     Write copy buffer to screen-exchange file.  *Note
     Screen-Exchange::.

`writelock ON|OFF|AUTO'
     Grant exclusive write permission.  *Note Multiuser::.

`xoff'
     Send an XOFF character.  *Note XON/XOFF::.

`xon'
     Send an XON character.  *Note XON/XOFF::.

`zombie [KEY]'
     Keep dead windows.  *Note Zombie::.


File: screen.info,  Node: New Window,  Next: Selecting,  Prev: Commands,  Up: Top

New Window
**********

   This section describes the commands for creating a new window for
running programs.  When a new window is created, the first available
number from the range 0...9 is assigned to it.  There can be no more
than 10 windows active at any one time.

* Menu:

* Chdir::                       Change the working directory for new windows.
* Screen Command::              Create a new window.
* Setenv::                      Set environment variables for new windows.
* Shell::                       Parameters for shell windows.
* Term::                        Set the terminal type for new windows.


File: screen.info,  Node: Chdir,  Next: Screen Command,  Up: New Window

Chdir
=====

 - Command: chdir [DIRECTORY]
     (none)
     Change the current directory of `screen' to the specified directory
     or, if called without an argument, to your home directory (the
     value of the environment variable `$HOME').  All windows that are
     created by means of the `screen' command from within `.screenrc'
     or by means of `C-a : screen ...' or `C-a c' use this as their
     default directory.  Without a `chdir' command, this would be the
     directory from which `screen' was invoked.  Hardcopy and log files
     are always written to the *window's* default directory, *not* the
     current directory of the process running in the window.  You can
     use this command multiple times in your `.screenrc' to start
     various windows in different default directories, but the last
     `chdir' value will affect all the windows you create interactively.


File: screen.info,  Node: Screen Command,  Next: Setenv,  Prev: Chdir,  Up: New Window

Screen Command
==============

 - Command: screen [OPTS] [N] [CMD [ARGS]]
     (`C-a c', `C-a C-c')
     Establish a new window.  The flow-control options (`-f', `-fn' and
     `-fa'), title option (`-t'), login options (`-l' and `-ln') ,
     terminal type option (`-T TERM') and scrollback option (`-h NUM')
     may be specified for each command.  If an optional number N in the
     range 0...9 is given, the window number N is assigned to the newly
     created window (or, if this number is already in-use, the next
     available number).  If a command is specified after `screen', this
     command (with the given arguments) is started in the window;
     otherwise, a shell is created.

   Thus, if your `.screenrc' contains the lines

     # example for .screenrc:
     screen 1
     screen -fn -t foobar 2 telnet foobar

`screen' creates a shell window (in window #1) and a window with a
TELNET connection to the machine foobar (with no flow-control using the
title `foobar' in window #2).  If you do not include any `screen'
commands in your `.screenrc' file, then `screen' defaults to creating a
single shell window, number zero.  When the initialization is
completed, `screen' switches to the last window specified in your
.screenrc file or, if none, it opens default window #0.


File: screen.info,  Node: Setenv,  Next: Shell,  Prev: Screen Command,  Up: New Window

Setenv
======

 - Command: setenv VAR STRING
     (none)
     Set the environment variable VAR to value STRING.  If only VAR is
     specified, the user will be prompted to enter a value.  If no
     parameters are specified, the user will be prompted for both
     variable and value. The environment is inherited by all
     subsequently forked shells.

 - Command: unsetenv VAR
     (none)
     Unset an environment variable.


File: screen.info,  Node: Shell,  Next: Term,  Prev: Setenv,  Up: New Window

Shell
=====

 - Command: shell COMMAND
     (none)
     Set the command to be used to create a new shell.  This overrides
     the value of the environment variable `$SHELL'.  This is useful if
     you'd like to run a tty-enhancer which is expecting to execute the
     program specified in `$SHELL'.  If the command begins with a `-'
     character, the shell will be started as a login-shell.

 - Command: shelltitle TITLE
     (none)
     Set the title for all shells created during startup or by the C-a
     C-c command.  *Note Naming Windows::, for details about what
     titles are.


File: screen.info,  Node: Term,  Prev: Shell,  Up: New Window

Term
====

 - Command: term TERM
     (none)
     In each window `screen' opens, it sets the `$TERM' variable to
     `screen' by default, unless no description for `screen' is
     installed in the local termcap or terminfo data base.  In that
     case it pretends that the terminal emulator is `vt100'.  This
     won't do much harm, as `screen' is VT100/ANSI compatible.  The use
     of the `term' command is discouraged for non-default purpose.
     That is, one may want to specify special `$TERM' settings (e.g.
     vt100) for the next `screen rlogin othermachine' command. Use the
     command `screen -T vt100 rlogin othermachine' rather than setting
     (`term vt100') and resetting (`term screen') the default before
     and after the `screen' command.


File: screen.info,  Node: Selecting,  Next: Session Management,  Prev: New Window,  Up: Top

Selecting a Window
******************

   This section describes the commands for switching between windows in
an `screen' session.  The windows are numbered from 0 to 9, and are
created in that order by default (*note New Window::.).

* Menu:

* Next and Previous::           Forward or back one window.
* Other Window::                Switch back and forth between two windows.
* Select::                      Specify a particular window.


File: screen.info,  Node: Next and Previous,  Next: Other Window,  Up: Selecting

Moving Back and Forth
=====================

 - Command: next
     (`C-a SPC', `C-a n', `C-a C-n')
     Switch to the next window.  This command can be used repeatedly to
     cycle through the list of windows.  (On some terminals, C-SPC
     generates a NUL character, so you must release the control key
     before pressing space.)

 - Command: prev
     (`C-a p', `C-a C-p')
     Switch to the previous window (the opposite of `C-a n').


File: screen.info,  Node: Other Window,  Next: Select,  Prev: Next and Previous,  Up: Selecting

Other Window
============

 - Command: other
     (`C-a C-a')
     Switch to the last window displayed.  Note that this command
     defaults to the command character typed twice, unless overridden;
     for instance, if you use the option `-e]x', this command becomes
     `]]', not `]C-a' (*note Command Character::.).  On the other hand,
     if you use the option `-e``', this command remains `` C-a', since
     ```' is bound to `meta'.


File: screen.info,  Node: Select,  Prev: Other Window,  Up: Selecting

Select
======

 - Command: select [N]
     (`C-a N', `C-a '', `C-a "')
     Switch to the window with the number N.  If no window number is
     specified, you get prompted for an identifier. This can be a
     window name (title) or a number.


File: screen.info,  Node: Session Management,  Next: Window Settings,  Prev: Selecting,  Up: Top

Session Management Commands
***************************

   Perhaps the most useful feature of `screen' is the way it allows the
user to move a session between terminals, by detaching and reattaching.
This also makes life easier for modem users who have to deal with
unexpected loss of carrier.

* Menu:

* Detach::                      Disconnect `screen' from your terminal.
* Power Detach::                Detach and log out.
* Lock::                        Lock your terminal temporarily.
* Multiuser Session::		Changing number of allowed users.
* Session Name::                Rename your session for later reattachment.
* Suspend::                     Suspend your session.
* Quit::                        Terminate your session.


File: screen.info,  Node: Detach,  Next: Power Detach,  Up: Session Management

Detach
======

 - Command: autodetach STATE
     (none)
     Sets whether `screen' will automatically detach upon hangup, which
     saves all your running programs until they are resumed with a
     `screen -r' command.  When turned off, a hangup signal will
     terminate `screen' and all the processes it contains. Autodetach is
     on by default.

 - Command: detach
     (`C-a d', `C-a C-d')
     Detach the `screen' session (disconnect it from the terminal and
     put it into the background).  A detached `screen' can be resumed by
     invoking `screen' with the `-r' option. (*note Invoking Screen::.)

 - Command: password [CRYPTED_PW]
     (none)
     Present a crypted password in your `.screenrc' file and screen will
     ask for it, whenever someone attempts to resume a detached
     session. This is useful, if you have privileged programs running
     under `screen' and you want to protect your session from reattach
     attempts by users that managed to assume your uid. (I.e. any
     superuser.)  If no crypted password is specified, screen prompts
     twice a password and places its encryption in the copybuffer.
     Default is `none', which disables password checking.


File: screen.info,  Node: Power Detach,  Next: Lock,  Prev: Detach,  Up: Session Management

Power Detach
============

 - Command: pow_detach
     (`C-a D')
     Mainly the same as `detach', but also sends a HANGUP signal to the
     parent process of `screen'.
     *Caution*: This will result in a logout if `screen' was started
     from your login shell.

 - Command: pow_detach_msg MESSAGE
     (none)
     The MESSAGE specified here is output whenever a power detach is
     performed. It may be used as a replacement for a logout message or
     to reset baud rate, etc.


File: screen.info,  Node: Lock,  Next: Multiuser Session,  Prev: Power Detach,  Up: Session Management

Lock
====

 - Command: lockscreen
     (`C-a x', `C-a C-x')
     Call a screenlock program (`/local/bin/lck' or `/usr/bin/lock' or
     a builtin, if no other is available). Screen does not accept any
     command keys until this program terminates. Meanwhile processes in
     the windows may continue, as the windows are in the detached state.
     The screenlock program may be changed through the environment
     variable `$LOCKPRG' (which must be set in the shell from which
     `screen' is started) and is executed with the user's uid and gid.


File: screen.info,  Node: Multiuser Session,  Next: Session Name,  Prev: Lock,  Up: Session Management

Multiuser Session
=================

   These commands allow other users to gain access to one single
`screen' session. When attaching to a multiuser `screen' the
sessionname is specified as `username/sessionname' to the `-S' command
line option.  `Screen' must be compiled with multiuser support to
enable features described here.

* Menu:

* Multiuser::			Enable / Disable multiuser mode.
* Acladd::			Enable a specific user.
* Aclchg::                      Change a users permissions.
* Acldel::			Disable a specific user.
* Wall::                        Write a message to all users.
* Writelock::                   Grant exclusive window access.


File: screen.info,  Node: Multiuser,  Next: Acladd,  Up: Multiuser Session

Multiuser
---------

 - Command: multiuser STATE
     (none)
     Switch between single-user and multi-user mode. Standard screen
     operation is single-user. In multi-user mode the commands `acladd'
     and `acldel' can be used to enable (and disable) other users
     accessing this `screen'.


File: screen.info,  Node: Acladd,  Next: Aclchg,  Prev: Multiuser,  Up: Multiuser Session

Acladd
------

 - Command: acladd USERNAME
     (none)
     Enable a user to (fully) access this screen session. Necessary to
     allow other users to attach to this `screen' session. Same as
     `aclchg USERNAME +rwx "#?"'. Multi-user mode only.


File: screen.info,  Node: Aclchg,  Next: Acldel,  Prev: Acladd,  Up: Multiuser Session

Aclchg
------

 - Command: aclchg USERNAME PERMBITS LIST
     (none)
     Change a users permissions. Permission bits are represented as `r',
     `w' and `x'. Prefixing `+' grants the permission, `-' removes it.
     The third parameter is a komma seperated list of commands or
     windows (specified either by number or title). The special list
     `#' refers to all windows, `?' to all commands.  A Command can be
     executed when the user has the `x' bit for it. the user can type
     input to a window, when he has its `w' bit set and no other user
     obtains a writelock for this window. Other bits are currently
     ignored.  Multi-user mode only.


File: screen.info,  Node: Acldel,  Next: Wall,  Prev: Aclchg,  Up: Multiuser Session

Acldel
------

 - Command: acldel USERNAME
     (none)
     Remove a user from screens access control list. If currently
     attached, all the users displays are detached from the session. He
     cannot attach again.  Multi-user mode only.


File: screen.info,  Node: Wall,  Next: Writelock,  Prev: Acldel,  Up: Multiuser Session

Wall
----

 - Command: wall MESSAGE ...
     (none)
     Write a message to all displays. The message will appear in the
     terminals status line.


File: screen.info,  Node: Writelock,  Prev: Wall,  Up: Multiuser Session

Writelock
---------

 - Command: writelock ON|OFF|AUTO
     (none)
     In addition to access control lists, not all users may be able to
     write to the same window at once. Per default, writelock is in
     `auto' mode and grants exclusive input permission to the user who
     is the first to switch to the particular window. When he leaves
     the window, other users may obtain the writelock (automatically).
     The writelock of the current window is disabled by the command
     `writelock off'. If the user issues the command `writelock on' he
     keeps the exclusive write permission while switching to other
     windows.


File: screen.info,  Node: Session Name,  Next: Suspend,  Prev: Multiuser Session,  Up: Session Management

Session Name
============

 - Command: sessionname [NAME]
     (none)
     Rename the current session. Note that for `screen -list' the name
     shows up with the process-id prepended. If the argument NAME is
     omitted, the name of this session is displayed.
     *Caution*: The `$STY' environment variable still reflects the old
     name. This may result in confusion.  The default is constructed
     from the tty and host names.


File: screen.info,  Node: Suspend,  Next: Quit,  Prev: Session Name,  Up: Session Management

Suspend
=======

 - Command: suspend
     (`C-a z', `C-a C-z')
     Suspend `screen'.  The windows are in the detached state while
     `screen' is suspended.  This feature relies on the parent shell
     being able to do job control.


File: screen.info,  Node: Quit,  Prev: Suspend,  Up: Session Management

Quit
====

 - Command: quit
     (`C-a C-\')
     Kill all windows and terminate `screen'.  Note that on vt100-style
     terminals the keys `C-4' and `C-\' are identical.  So be careful
     not to type `C-a C-4' when selecting window no. 4.  Use the empty
     bind command (as in `bind "^\"') to remove a key binding (*note
     Key Binding::.).


File: screen.info,  Node: Window Settings,  Next: Virtual Terminal,  Prev: Session Management,  Up: Top

Window Settings
***************

   These commands control the way `screen' treats individual windows in
a session.  *Note Virtual Terminal::, for comands to control the
terminal emulation itself.

* Menu:

* Naming Windows::               Control the name of the window
* Autonuke::			Flush unseen output
* Console::			See the host's console messages
* Kill::                        Destroy an unwanted window
* Login::                       Control `/etc/utmp' logging
* Mode::                        Control the file mode of the pty
* Monitor::                     Watch for activity in a window
* Obuflimit::			Allow pending output when reading more
* Windows::                     List the active windows


File: screen.info,  Node: Naming Windows,  Next: Autonuke,  Up: Window Settings

Naming Windows (Titles)
=======================

   You can customize each window's name in the window display (viewed
with the `windows' command (*note Windows::.) by setting it with one of
the title commands.  Normally the name displayed is the actual command
name of the program created in the window.  However, it is sometimes
useful to distinguish various programs of the same name or to change
the name on-the-fly to reflect the current state of the window.

   The default name for all shell windows can be set with the
`shelltitle' command (*note Shell::.).  You can specify the name you
want for a window with the `-t' option to the `screen' command when the
window is created (*note Screen Command::.).  To change the name after
the window has been created you can use the title-string escape-sequence
(`ESC k NAME ESC \') and the `title' command (C-a A).  The former can
be output from an application to control the window's name under
software control, and the latter will prompt for a name when typed.
You can also bind predefined names to keys with the `title' command to
set things quickly without prompting.

* Menu:

* Title Command::                 The `title' command.
* Dynamic Titles::                Make shell windows change titles dynamically.
* Title Prompts::                 Set up your shell prompt for dynamic Titles.
* Title Screenrc::                Set up Titles in your `.screenrc'.


File: screen.info,  Node: Title Command,  Next: Dynamic Titles,  Up: Naming Windows

Title Command
-------------

 - Command: title [WINDOWTITLE]
     (`C-a A')
     Set the name of the current window to WINDOWALIAS. If no name is
     specified, screen prompts for one.


File: screen.info,  Node: Dynamic Titles,  Next: Title Prompts,  Prev: Title Command,  Up: Naming Windows

Dynamic Titles
--------------

   `screen' has a shell-specific heuristic that is enabled by setting
the window's name to SEARCH|NAME and arranging to have a null title
escape-sequence output as a part of your prompt.  The SEARCH portion
specifies an end-of-prompt search string, while the NAME portion
specifies the default shell name for the window.  If the NAME ends in a
`:' `screen' will add what it believes to be the current command
running in the window to the end of the specified name (e.g. NAME:CMD).
Otherwise the current command name supersedes the shell name while it
is running.

   Here's how it works: you must modify your shell prompt to output a
null title-escape-sequence (ESC k ESC \) as a part of your prompt.  The
last part of your prompt must be the same as the string you specified
for the SEARCH portion of the title.  Once this is set up, `screen'
will use the title-escape-sequence to clear the previous command name
and get ready for the next command.  Then, when a newline is received
from the shell, a search is made for the end of the prompt.  If found,
it will grab the first word after the matched string and use it as the
command name.  If the command name begins with `!', `%', or `^',
`screen' will use the first word on the following line (if found) in
preference to the just-found name.  This helps csh users get more
accurate titles when using job control or history recall commands.


File: screen.info,  Node: Title Prompts,  Next: Title Screenrc,  Prev: Dynamic Titles,  Up: Naming Windows

Setting up your prompt for shell titles
---------------------------------------

   One thing to keep in mind when adding a null title-escape-sequence
to your prompt is that some shells (like the csh) count all the
non-control characters as part of the prompt's length.  If these
invisible characters aren't a multiple of 8 then backspacing over a tab
will result in an incorrect display.  One way to get around this is to
use a prompt like this:

     set prompt='[0000mk\% '

   The escape-sequence `[0000m' not only normalizes the character
attributes, but all the zeros round the length of the invisible
characters up to 8.

   Tcsh handles escape codes in the prompt more intelligently, so you
can specify your prompt like this:

     set prompt="%{\ek\e\\%}\% "

   Bash users will probably want to echo the escape sequence in the
PROMPT_COMMAND:

     PROMPT_COMMAND='echo -n -e "\033k\033\134"'

   (I used `\134' to output a `\' because of a bug in v1.04).

